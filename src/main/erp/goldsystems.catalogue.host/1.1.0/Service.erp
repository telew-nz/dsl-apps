extend entity BullionCatalogueService {

	object field workspacesToMonitor: [String]?
    system field updateWorkspacesToMonitorJob: UpdateWorkspacesToMonitorJob inline by service
    system field updateCatalogueProductsJob: UpdateCatalogueProductsJob inline by service
    
    extend view form = y{ 
    	workspacesToMonitor >> field(label = "Monitored workspaces", editMode = AlwaysRead)
        y(visible = !id.toString.startsWith("-")){
            button("Update workspaces to monitor") {
            	Activity.current!.comment("Updating workspaces to monitor.")
                updateWorkspacesToMonitorJob.enqueueFirst
            }
            button("Update catalogue products") {
            	Activity.current!.comment("Updating catalogue products.")
                updateCatalogueProductsJob.enqueueFirst
            }
        }
    }

}


inline entity UpdateWorkspacesToMonitorJob extends ScheduledJob {

    impl field service: BullionCatalogueService by updateWorkspacesToMonitorJob
    impl func schedule = "0 24 * * * ?"
    field invokedManually: Bool = false
    impl func do: Future[Any] = {
        let wids <- Workspace.getAllIds.map(filter(_ != "18_12"))
        let res <- wids.oneByOne(wid => {
            let sid = ShortIdDb(wid)
            if (sid.cluster == 17) Workspace.all.inWorkspaceFullWid(17, sid.position)
            	.map(apps.keys.toSeq.exists(_ == "goldsystems.catalogue.client")).result.map((wid, _.first!))
            else Workspace.all.inWorkspaceFullWid(18, sid.position)
            	.map(apps.keys.toSeq.exists(_ == "goldsystems.catalogue.client")).result.map((wid, _.first!))
        }).flatMap(_).map(filter(#1)).map(map(#0))
        BullionCatalogueService.workspacesToMonitor = res
        service.save
    }
    
}


inline entity UpdateCatalogueProductsJob extends ScheduledJob {

    impl field service: BullionCatalogueService by updateCatalogueProductsJob
    impl func schedule = "0 42 * * * ?"
    impl func do: Future[Any] = {
    	BullionSuperProduct.search("something impossible").unionFuture(BullionCatalogueService.workspacesToMonitor.oneByOne(wid => {
                let sid = ShortIdDb(wid)
                if (sid.cluster == 17) {
                	let allProducts <- BullionSuperProduct.all.inWorkspaceTry(17, sid.position, true).result
                    let sharedProducts <- SharedItem.all.inWorkspaceTry(17, sid.position, true).result
                    allProducts.filter(!sharedProducts.exists(sp => _.id != sp.id))
                }
                else if (sid.cluster == 18) {
                	let allProducts <- BullionSuperProduct.all.inWorkspaceTry(18, sid.position, true).result
                    let sharedProducts <- SharedItem.all.inWorkspaceTry(18, sid.position, true).result
                    allProducts.filter(!sharedProducts.exists(sp => _.id != sp.id))
                }
                else Future([]).as[Future[[BullionSuperProduct]?]]
            }).flatMap(res => res.flatMap(_)))
        		.filter(p => p.id)
        		.map { LinkedBullionProduct(linkedEntityId = _.id.toString!, linkedEntityTitle = _.title) }
            	.union { LinkedBullionProduct.all }
            	.distinct
                .groupBy { linkedEntityId }
                .flatMap {
                	if (_.items.count > 3) throw "Unexpected case (>3 linked entities with the same id)"
                    else if (_.items.count == 2) _.items.filter(i => !i.id.toString.startsWith("-"))
                    else _.items
                }
        		.foreach { save }
    }
    
}